#region

using System.ComponentModel.DataAnnotations;
using HimuOJ.Common.WebHostDefaults.Extensions;

#endregion

namespace HimuOJ.Services.Problems.Domain.AggregatesModel.ProblemAggregate;

/// <summary>
///     The <see cref="Problem" /> is the basic unit for users to submit test.
/// </summary>
public class Problem : Entity, IAggregateRoot
{
    private readonly List<TestPoint> _testPoints;

    protected Problem()
    {
        _testPoints = new List<TestPoint>();
    }

    public Problem(
        Guid? distributorId,
        string title,
        string content,
        ResourceLimit resourceLimit,
        GuestAccessLimit guestAccessLimit)
        : this()
    {
        DistributorId        = distributorId;
        Title                = title;
        Content              = content;
        CreateTime           = DateTime.UtcNow;
        LastModifyTime       = DateTime.UtcNow;
        DefaultResourceLimit = resourceLimit;
        GuestAccessLimit     = guestAccessLimit;
    }

    public Guid? DistributorId { get; private set; }

    [Required]
    public string Title { get; private set; }

    /// <summary>
    ///     Content should be MarkDown format.
    /// </summary>
    [Required]
    public string Content { get; private set; }

    public DateTime CreateTime { get; private set; }

    public DateTime LastModifyTime { get; private set; }

    /// <summary>
    ///     The default resource limit for each test point in this problem.
    /// </summary>
    [Required]
    public ResourceLimit DefaultResourceLimit { get; private set; }

    [Required]
    public GuestAccessLimit GuestAccessLimit { get; private set; }

    public IReadOnlyCollection<TestPoint> TestPoints => _testPoints.AsReadOnly();

    public bool Update(
        string title,
        string content,
        long maxMemoryLimitByte,
        long maxRealTimeLimitMilliseconds,
        bool allowDownloadInput,
        bool allowDownloadAnswer,
        IEnumerable<TestPoint> testPointsUpdated)
    {
        Title          = title;
        Content        = content;
        LastModifyTime = DateTime.UtcNow;

        DefaultResourceLimit.Update(maxMemoryLimitByte, maxRealTimeLimitMilliseconds);
        GuestAccessLimit.Update(allowDownloadInput, allowDownloadAnswer);

        var intersection = testPointsUpdated
            .IntersectWithDifference(_testPoints, out var testPointsAdded)
            .ToHashSet();
        
        var currentTestPoints = _testPoints.ToList();
        for (int i = 0; i < currentTestPoints.Count; i++)
        {
            bool found = intersection.TryGetValue(currentTestPoints[i], out var testPointToUpdate);
            if (found)
            {
                _testPoints[i]
                    .Update(
                        testPointToUpdate.Input,
                        testPointToUpdate.ExpectedOutput,
                        testPointToUpdate.Remarks);
            }
        }

        foreach (var testPoint in testPointsAdded)
        {
            if (testPoint.Id != 0)
                return false;
            _testPoints.Add(testPoint);
        }
        
        return true;
    }

    public void AddTestPoint(string input, string expectedOutput, string remarks)
    {
        // ID will be generated by EF Core.
        _testPoints.Add(new TestPoint(0, Id, input, expectedOutput, remarks));
    }

    public void AddTestPoint(string input, string expectedOutput, string remarks, TestPointResourceType resourceType)
    {
        // ID will be generated by EF Core.
        _testPoints.Add(new TestPoint(0, Id, input, expectedOutput, remarks, resourceType));
    }

    /// <summary>
    /// Removes a test point by its ID.
    /// </summary>
    /// <param name="testPointId">The ID of the test point to remove.</param>
    /// <returns>The ID of the removed test point, or -1 if the test point was not found.</returns>
    public int RemoveTestPoint(int testPointId)
    {
        var index = _testPoints.FindIndex(x => x.Id == testPointId);
        if (index == -1)
            return -1;
        int removedId = _testPoints[index].Id;
        _testPoints.RemoveAt(index);
        return removedId;
    }
}